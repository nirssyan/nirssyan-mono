apiVersion: v1
kind: ConfigMap
metadata:
  name: storage-init-scripts
data:
  init-telegram-bucket.sh: |
    #!/bin/sh
    set -e

    echo "Waiting for PostgreSQL to be ready..."
    MAX_RETRIES=30
    RETRY_DELAY=2
    retry_count=0

    until pg_isready -h supabase-postgres -p 5432 -U supabase_admin; do
      retry_count=$((retry_count + 1))
      if [ $retry_count -ge $MAX_RETRIES ]; then
        echo "❌ PostgreSQL not ready after $MAX_RETRIES attempts"
        exit 1
      fi
      echo "PostgreSQL unavailable - waiting ($retry_count/$MAX_RETRIES)"
      sleep "$RETRY_DELAY"
    done

    echo "✅ PostgreSQL is ready"
    echo "Waiting for Storage API to create schema..."

    # Wait for storage.buckets table to exist (Storage API migrations)
    retry_count=0
    until PGPASSWORD="$POSTGRES_PASSWORD" psql -h supabase-postgres -U supabase_admin -d postgres -tAc "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'storage' AND table_name = 'buckets');" | grep -q "t"; do
      retry_count=$((retry_count + 1))
      if [ $retry_count -ge $MAX_RETRIES ]; then
        echo "❌ storage.buckets table not created after $MAX_RETRIES attempts"
        exit 1
      fi
      echo "Waiting for storage.buckets table ($retry_count/$MAX_RETRIES)..."
      sleep "$RETRY_DELAY"
    done

    echo "✅ Storage schema is ready"

    # Fix search_path for all roles to find storage.buckets
    # The Storage API uses SET ROLE to switch to service_role/anon/authenticated,
    # so these roles need search_path configured, not just supabase_storage_admin
    echo "Configuring search_path and permissions for storage roles..."
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h supabase-postgres -U supabase_admin -d postgres <<-'EOSQL'
      -- Set search_path at database level
      ALTER DATABASE postgres SET search_path TO storage, public, extensions;

      -- Set search_path for all roles that access storage
      ALTER ROLE supabase_storage_admin SET search_path TO storage, public, extensions;
      ALTER ROLE service_role SET search_path TO storage, public, extensions;
      ALTER ROLE anon SET search_path TO storage, public, extensions;
      ALTER ROLE authenticated SET search_path TO storage, public, extensions;

      -- Grant schema access to JWT roles
      GRANT USAGE ON SCHEMA storage TO service_role, anon, authenticated;

      -- Grant table permissions
      GRANT ALL ON ALL TABLES IN SCHEMA storage TO service_role;
      GRANT SELECT ON ALL TABLES IN SCHEMA storage TO anon, authenticated;
      GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO service_role;
      GRANT SELECT ON ALL SEQUENCES IN SCHEMA storage TO anon, authenticated;

      -- Make sure future tables also get correct grants
      ALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON TABLES TO service_role;
      ALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT SELECT ON TABLES TO anon, authenticated;
      ALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT ALL ON SEQUENCES TO service_role;
      ALTER DEFAULT PRIVILEGES IN SCHEMA storage GRANT SELECT ON SEQUENCES TO anon, authenticated;
    EOSQL
    echo "✅ search_path and permissions configured"

    echo "Creating telegram-sessions bucket..."

    PGPASSWORD="$POSTGRES_PASSWORD" psql -h supabase-postgres -U supabase_admin -d postgres <<-EOSQL
      -- Create telegram-sessions bucket
      INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
      VALUES (
        'telegram-sessions',
        'telegram-sessions',
        false,
        10485760,
        ARRAY['application/octet-stream']
      )
      ON CONFLICT (id) DO UPDATE SET
        file_size_limit = EXCLUDED.file_size_limit,
        allowed_mime_types = EXCLUDED.allowed_mime_types;

      -- RLS: service_role only access
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Service role only - telegram sessions'
        ) THEN
          CREATE POLICY "Service role only - telegram sessions"
          ON storage.objects FOR ALL
          TO service_role
          USING (bucket_id = 'telegram-sessions')
          WITH CHECK (bucket_id = 'telegram-sessions');
        END IF;
      END\$\$;

      -- Block anonymous users
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Block anon - telegram sessions'
        ) THEN
          CREATE POLICY "Block anon - telegram sessions"
          ON storage.objects FOR ALL
          TO anon
          USING (false);
        END IF;
      END\$\$;

      -- Block authenticated users
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Block authenticated - telegram sessions'
        ) THEN
          CREATE POLICY "Block authenticated - telegram sessions"
          ON storage.objects FOR ALL
          TO authenticated
          USING (false);
        END IF;
      END\$\$;

      -- Verify bucket was created
      SELECT id, name, public, file_size_limit
      FROM storage.buckets
      WHERE id = 'telegram-sessions';
    EOSQL

    echo "✅ Telegram sessions bucket initialized successfully"

    echo "Creating telegram-media bucket..."

    PGPASSWORD="$POSTGRES_PASSWORD" psql -h supabase-postgres -U supabase_admin -d postgres <<-EOSQL
      -- Create telegram-media bucket (for storing media files from Telegram posts)
      INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
      VALUES (
        'telegram-media',
        'telegram-media',
        true,
        52428800,
        ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'application/octet-stream']
      )
      ON CONFLICT (id) DO UPDATE SET
        public = EXCLUDED.public,
        file_size_limit = EXCLUDED.file_size_limit,
        allowed_mime_types = EXCLUDED.allowed_mime_types;

      -- RLS: Allow service_role full access to telegram-media bucket
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Service role access - telegram media'
        ) THEN
          CREATE POLICY "Service role access - telegram media"
          ON storage.objects FOR ALL
          TO service_role
          USING (bucket_id = 'telegram-media')
          WITH CHECK (bucket_id = 'telegram-media');
        END IF;
      END\$\$;

      -- RLS: Allow public read access for telegram-media bucket (since it's public)
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Public read - telegram media'
        ) THEN
          CREATE POLICY "Public read - telegram media"
          ON storage.objects FOR SELECT
          TO anon, authenticated
          USING (bucket_id = 'telegram-media');
        END IF;
      END\$\$;

      -- Verify buckets were created
      SELECT id, name, public, file_size_limit
      FROM storage.buckets
      WHERE id IN ('telegram-sessions', 'telegram-media');
    EOSQL

    echo "✅ Telegram media bucket initialized successfully"

    echo "Creating permanent-media bucket..."

    PGPASSWORD="$POSTGRES_PASSWORD" psql -h supabase-postgres -U supabase_admin -d postgres <<-EOSQL
      -- Create permanent-media bucket (for logos and other permanent assets)
      INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
      VALUES (
        'permanent-media',
        'permanent-media',
        true,
        10485760,
        ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml']
      )
      ON CONFLICT (id) DO UPDATE SET
        public = EXCLUDED.public,
        file_size_limit = EXCLUDED.file_size_limit,
        allowed_mime_types = EXCLUDED.allowed_mime_types;

      -- RLS: Allow service_role full access
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Service role access - permanent media'
        ) THEN
          CREATE POLICY "Service role access - permanent media"
          ON storage.objects FOR ALL
          TO service_role
          USING (bucket_id = 'permanent-media')
          WITH CHECK (bucket_id = 'permanent-media');
        END IF;
      END\$\$;

      -- RLS: Allow public read access
      DO \$\$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_policies
          WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname = 'Public read - permanent media'
        ) THEN
          CREATE POLICY "Public read - permanent media"
          ON storage.objects FOR SELECT
          TO anon, authenticated
          USING (bucket_id = 'permanent-media');
        END IF;
      END\$\$;

      SELECT id, name, public FROM storage.buckets WHERE id = 'permanent-media';
    EOSQL

    echo "✅ Permanent media bucket initialized successfully"
