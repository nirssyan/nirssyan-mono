"""Feed repository for database operations."""

from typing import Any, cast
from uuid import UUID

from sqlalchemy import delete, func, insert, select, text, update
from sqlalchemy.ext.asyncio import AsyncConnection

from shared.database.tables import (
    chats,
    feeds,
    pre_prompts,
    prompts,
    users_feeds,
)
from shared.enums import FeedType, PrePromptType


class FeedRepository:
    """Repository for feed-related database operations."""

    async def create_feed(
        self,
        conn: AsyncConnection,
        title: str,
        description: str | None = None,
        tags: list[str] | None = None,
        chat_id: UUID | None = None,
        feed_type: FeedType = FeedType.SINGLE_POST,
    ) -> dict[str, Any]:
        """Create a new feed with the given title, description, tags, and chat_id.

        Args:
            conn: Database connection
            title: Feed title
            description: Feed description (optional)
            tags: List of feed tags (optional)
            chat_id: ID of the chat this feed belongs to (optional, must be unique)
            feed_type: Type of feed (SINGLE_POST or DIGEST)

        Returns:
            Dictionary containing the created feed data
        """
        query = (
            insert(feeds)
            .values(
                name=title,
                description=description,
                tags=tags,
                type=feed_type.value,
                is_creating_finished=False,
                chat_id=chat_id,
            )
            .returning(feeds)
        )
        result = await conn.execute(query)
        row = result.fetchone()
        if row is None:
            raise ValueError("Failed to create feed")
        return dict(row._mapping)

    async def feed_exists_for_chat(
        self,
        conn: AsyncConnection,
        chat_id: UUID,
    ) -> bool:
        """Check if a feed already exists for the given chat_id.

        Args:
            conn: Database connection
            chat_id: ID of the chat to check

        Returns:
            True if a feed exists for this chat, False otherwise
        """
        query = select(feeds.c.id).where(feeds.c.chat_id == chat_id)
        result = await conn.execute(query)
        return result.fetchone() is not None

    async def create_pre_prompt(
        self,
        conn: AsyncConnection,
        sources: list[str],
        pre_prompt_type: PrePromptType,
        prompt_text: str | None = None,
        description: str | None = None,
        title: str | None = None,
        tags: list[str] | None = None,
    ) -> dict[str, Any]:
        """Create a pre_prompt record for feed creation.

        Args:
            conn: Database connection
            sources: List of source URLs
            pre_prompt_type: Type of pre_prompt (SINGLE_POST or DIGEST)
            prompt_text: Optional prompt text
            description: Optional feed description
            title: Optional feed title
            tags: Optional list of tags

        Returns:
            Dictionary containing the created pre_prompt data
        """
        query = (
            insert(pre_prompts)
            .values(
                sources=sources,
                type=pre_prompt_type,
                prompt=prompt_text,
                description=description,
                title=title,
                tags=tags,
                is_ready_to_create_feed=True,
            )
            .returning(pre_prompts)
        )
        result = await conn.execute(query)
        row = result.fetchone()
        if row is None:
            raise ValueError("Failed to create pre_prompt")
        return dict(row._mapping)

    async def create_prompt(
        self,
        conn: AsyncConnection,
        feed_id: UUID,
        prompt: str,
        feed_type: str,
        pre_prompt_id: UUID,
        digest_interval_hours: int | None = None,
        filters: list[str] | None = None,
        views_config: list[dict] | None = None,
        filters_config: list[dict] | None = None,
    ) -> dict[str, Any]:
        """Create a prompt entry linking feed to pre_prompt.

        Args:
            conn: Database connection
            feed_id: ID of the feed
            prompt: The prompt text
            feed_type: Type of Telegram feed
            pre_prompt_id: ID of the pre_prompt
            digest_interval_hours: Interval in hours between digest generation (1-48).
                Only for SUMMARY type. None means default 12 hours.
            filters: List of predefined filter names (e.g., ["remove_ads", "remove_duplicates"]).
                Defaults to empty list if not provided.
            views_config: AI-transformed view configs [{name, prompt}].
                Generated by ViewPromptTransformerAgent from user-defined views.
            filters_config: AI-transformed filter configs [{name, prompt}].
                Generated by ViewPromptTransformerAgent from user-defined filters.

        Returns:
            Dictionary containing the created prompt data
        """
        prompt_jsonb = {
            "instruction": prompt,
            "filters": filters or [],
        }

        query = (
            insert(prompts)
            .values(
                feed_id=feed_id,
                prompt=prompt_jsonb,
                feed_type=feed_type,
                pre_prompt_id=pre_prompt_id,
                digest_interval_hours=digest_interval_hours,
                views_config=views_config or [],
                filters_config=filters_config or [],
            )
            .returning(prompts)
        )
        result = await conn.execute(query)
        row = result.fetchone()
        if row is None:
            raise ValueError("Failed to create prompt")

        return dict(row._mapping)

    async def create_user_feed_association(
        self, conn: AsyncConnection, user_id: UUID, feed_id: UUID
    ) -> bool:
        """Create association between user and feed with conflict handling.

        Args:
            conn: Database connection
            user_id: ID of the user
            feed_id: ID of the feed

        Returns:
            True if association was created, False if it already existed
        """
        from sqlalchemy.dialects.postgresql import insert as pg_insert

        query = pg_insert(users_feeds).values(user_id=user_id, feed_id=feed_id)
        query = query.on_conflict_do_nothing(index_elements=["user_id", "feed_id"])

        result = await conn.execute(query)
        # If rowcount is 0, the association already existed
        return bool(int(result.rowcount or 0) > 0)

    async def count_feed_subscribers(self, conn: AsyncConnection, feed_id: UUID) -> int:
        """Count number of users subscribed to a feed.

        Args:
            conn: Database connection
            feed_id: ID of the feed

        Returns:
            Number of subscribers
        """
        query = (
            select(func.count())
            .select_from(users_feeds)
            .where(users_feeds.c.feed_id == feed_id)
        )
        result = await conn.execute(query)
        count = result.scalar()
        return int(count) if count is not None else 0

    async def count_user_feeds(self, conn: AsyncConnection, user_id: UUID) -> int:
        """Count total number of feeds for a user.

        Args:
            conn: Database connection
            user_id: ID of the user

        Returns:
            Number of feeds owned by the user
        """
        query = (
            select(func.count())
            .select_from(users_feeds)
            .where(users_feeds.c.user_id == user_id)
        )
        result = await conn.execute(query)
        count = result.scalar()
        return int(count) if count is not None else 0

    async def count_user_feeds_by_prompts(
        self, conn: AsyncConnection, user_id: UUID
    ) -> int:
        """Count number of feeds owned by user through their prompts.

        A feed is considered owned by user if there's a prompt linked to it
        through the user's chat (user -> chat -> pre_prompt -> prompt -> feed).

        Args:
            conn: Database connection
            user_id: ID of the user

        Returns:
            Number of feeds with prompts owned by the user
        """
        # Get unique feed_ids from prompts that belong to user's chats
        query = (
            select(func.count(func.distinct(prompts.c.feed_id)))
            .select_from(prompts)
            .where(
                prompts.c.pre_prompt_id.in_(
                    select(chats.c.pre_prompt_id).where(chats.c.user_id == user_id)
                )
            )
        )
        result = await conn.execute(query)
        count = result.scalar()
        return int(count) if count is not None else 0

    async def get_user_id_by_feed_id(
        self, conn: AsyncConnection, feed_id: UUID
    ) -> UUID | None:
        """Get first user_id associated with a feed_id.

        Args:
            conn: Database connection
            feed_id: ID of the feed

        Returns:
            UUID of the first user subscribed to the feed, or None if no users
        """
        query = (
            select(users_feeds.c.user_id)
            .where(users_feeds.c.feed_id == feed_id)
            .limit(1)
        )
        result = await conn.execute(query)
        row = result.fetchone()
        return cast(UUID, row.user_id) if row else None

    async def delete_user_feed_association(
        self, conn: AsyncConnection, user_id: UUID, feed_id: UUID
    ) -> None:
        """Delete association between user and feed.

        Args:
            conn: Database connection
            user_id: ID of the user
            feed_id: ID of the feed
        """
        query = delete(users_feeds).where(
            (users_feeds.c.user_id == user_id) & (users_feeds.c.feed_id == feed_id)
        )
        await conn.execute(query)

    async def delete_feed(self, conn: AsyncConnection, feed_id: UUID) -> None:
        """Delete a feed and all associated data (cascades to prompts).

        Args:
            conn: Database connection
            feed_id: ID of the feed to delete
        """
        query = delete(feeds).where(feeds.c.id == feed_id)
        await conn.execute(query)

    async def check_feed_exists(self, conn: AsyncConnection, feed_id: UUID) -> bool:
        """Check if a feed exists.

        Args:
            conn: Database connection
            feed_id: ID of the feed to check

        Returns:
            True if feed exists, False otherwise
        """
        query = select(func.count()).select_from(feeds).where(feeds.c.id == feed_id)
        result = await conn.execute(query)
        count = result.scalar()
        return bool(int(count) > 0) if count is not None else False

    async def rename_feed(
        self, conn: AsyncConnection, feed_id: UUID, new_name: str
    ) -> None:
        """Update the name of a feed.

        Args:
            conn: Database connection
            feed_id: ID of the feed to rename
            new_name: New name for the feed
        """
        query = update(feeds).where(feeds.c.id == feed_id).values(name=new_name)
        await conn.execute(query)

    async def update_feed_tags(
        self, conn: AsyncConnection, feed_id: UUID, tags: list[str]
    ) -> dict[str, Any]:
        """Update the tags of a feed.

        Args:
            conn: Database connection
            feed_id: ID of the feed to update
            tags: List of 1-4 tags to set

        Returns:
            Dictionary containing the updated feed data

        Raises:
            ValueError: If feed not found or tags validation fails
        """
        # Validate tags count (1-4)
        if not tags or len(tags) < 1:
            raise ValueError("Minimum 1 tag required")
        if len(tags) > 4:
            raise ValueError("Maximum 4 tags allowed")

        # Update feed tags
        query = (
            update(feeds)
            .where(feeds.c.id == feed_id)
            .values(tags=tags)
            .returning(feeds)
        )
        result = await conn.execute(query)
        row = result.fetchone()

        if row is None:
            raise ValueError(f"Feed with id {feed_id} not found")

        return dict(row._mapping)

    async def get_user_feeds_metadata(
        self, conn: AsyncConnection, user_id: UUID
    ) -> list[dict[str, Any]]:
        """Get all feeds for a user with unread counts, without posts.

        Args:
            conn: Database connection
            user_id: ID of the user

        Returns:
            List of dictionaries containing feed metadata and unread_count
        """
        query = text("""
            SELECT
              feeds.id,
              feeds.name,
              feeds.created_at,
              feeds.tags,
              feeds.is_creating_finished,
              prompts.feed_type as type,
              (
                  SELECT COUNT(*) FROM posts p
                  LEFT JOIN posts_seen ps ON p.id = ps.post_id AND ps.user_id = :user_id
                  WHERE p.feed_id = feeds.id AND (ps.seen IS NULL OR ps.seen = false)
              ) as unread_count,
              (
                  SELECT COUNT(*) FROM posts p WHERE p.feed_id = feeds.id
              ) as posts_count,
              (
                  SELECT COALESCE(SUM(cnt), 0) FROM (
                      SELECT COUNT(*) as cnt
                      FROM raw_posts rp
                      JOIN prompts_raw_feeds prf ON rp.raw_feed_id = prf.raw_feed_id
                      JOIN prompts_raw_feeds_offsets prfo
                          ON prf.prompt_id = prfo.prompt_id
                          AND prf.raw_feed_id = prfo.raw_feed_id
                      JOIN raw_posts offset_post
                          ON prfo.last_processed_raw_post_id = offset_post.id
                      WHERE prf.prompt_id = prompts.id
                          AND (rp.moderation_action IS NULL
                               OR rp.moderation_action != 'block')
                          AND rp.created_at <= offset_post.created_at
                      GROUP BY prf.raw_feed_id
                  ) sub
              ) as raw_posts_processed,
              (
                  SELECT COUNT(DISTINCT prf.raw_feed_id)
                  FROM prompts_raw_feeds prf
                  WHERE prf.prompt_id = prompts.id
              ) as raw_feeds_count
            FROM users_feeds
            INNER JOIN feeds ON users_feeds.feed_id = feeds.id
            LEFT JOIN prompts ON feeds.id = prompts.feed_id
            WHERE users_feeds.user_id = :user_id
            ORDER BY feeds.created_at DESC
        """)

        result = await conn.execute(query, {"user_id": user_id})
        rows = result.fetchall()
        return [dict(row._mapping) for row in rows]

    async def check_user_feed_access(
        self, conn: AsyncConnection, user_id: UUID, feed_id: UUID
    ) -> bool:
        """Check if user has access to a specific feed.

        Args:
            conn: Database connection
            user_id: ID of the user
            feed_id: ID of the feed

        Returns:
            True if user has access, False otherwise
        """
        query = (
            select(func.count())
            .select_from(users_feeds)
            .where(
                (users_feeds.c.user_id == user_id) & (users_feeds.c.feed_id == feed_id)
            )
        )
        result = await conn.execute(query)
        count = result.scalar()
        return bool(int(count) > 0) if count is not None else False

    async def get_feed_with_owner(
        self, conn: AsyncConnection, feed_id: UUID
    ) -> dict[str, Any] | None:
        """Get feed with owner information from auth.users.

        Args:
            conn: Database connection
            feed_id: ID of the feed

        Returns:
            Dictionary with feed data and owner info, or None if feed not found
        """
        query = text("""
            SELECT
                f.id,
                f.name,
                f.description,
                f.created_at,
                f.type,
                u.id as owner_id,
                COALESCE(
                    u.raw_user_meta_data->>'full_name',
                    u.email,
                    'Unknown User'
                ) as owner_name,
                p.prompt,
                p.feed_type,
                p.views_config,
                p.filters_config,
                pp.sources,
                (
                    SELECT json_agg(json_build_object(
                        'en', rf.name,
                        'ru', rf.name,
                        'url', CASE
                            WHEN rf.raw_type = 'TELEGRAM' THEN 'https://t.me/' || rf.telegram_username
                            ELSE rf.feed_url
                        END,
                        'type', rf.raw_type::text
                    ))
                    FROM prompts_raw_feeds prf
                    INNER JOIN raw_feeds rf ON rf.id = prf.raw_feed_id
                    WHERE prf.prompt_id = p.id
                ) as source_names
            FROM feeds f
            INNER JOIN users_feeds uf ON f.id = uf.feed_id
            INNER JOIN auth.users u ON uf.user_id = u.id
            LEFT JOIN prompts p ON p.feed_id = f.id
            LEFT JOIN pre_prompts pp ON p.pre_prompt_id = pp.id
            WHERE f.id = :feed_id
            LIMIT 1
        """)

        result = await conn.execute(query, {"feed_id": feed_id})
        row = result.fetchone()
        return dict(row._mapping) if row else None

    async def get_all_post_ids_for_feed(
        self, conn: AsyncConnection, feed_id: UUID
    ) -> list[UUID]:
        """Get all post IDs for a specific feed.

        Args:
            conn: Database connection
            feed_id: ID of the feed

        Returns:
            List of post UUIDs for the feed
        """
        from shared.database.tables import posts

        query = select(posts.c.id).where(posts.c.feed_id == feed_id)
        result = await conn.execute(query)
        rows = result.fetchall()
        return [cast(UUID, row.id) for row in rows]

    async def update_feed_creating_status(
        self,
        conn: AsyncConnection,
        feed_id: UUID,
        status: bool | None,
    ) -> None:
        """Update feed creating status.

        Args:
            conn: Database connection
            feed_id: Feed UUID
            status: True=success, False=in progress, None=error
        """
        from shared.database.tables import feeds

        query = (
            update(feeds)
            .where(feeds.c.id == feed_id)
            .values(is_creating_finished=status)
        )
        await conn.execute(query)

    async def update_feed_description(
        self,
        conn: AsyncConnection,
        feed_id: UUID,
        description: str,
    ) -> None:
        """Update feed description.

        Args:
            conn: Database connection
            feed_id: Feed UUID
            description: New description for the feed
        """
        query = (
            update(feeds).where(feeds.c.id == feed_id).values(description=description)
        )
        await conn.execute(query)

    async def update_prompt_configs(
        self,
        conn: AsyncConnection,
        prompt_id: UUID,
        views_config: list[dict] | None = None,
        filters_config: list[dict] | None = None,
    ) -> None:
        """Update prompt views_config and filters_config.

        Args:
            conn: Database connection
            prompt_id: Prompt UUID
            views_config: AI-transformed view configs [{name, prompt}]
            filters_config: AI-transformed filter configs [{name, prompt}]
        """
        values: dict[str, Any] = {}
        if views_config is not None:
            values["views_config"] = views_config
        if filters_config is not None:
            values["filters_config"] = filters_config

        if not values:
            return

        query = update(prompts).where(prompts.c.id == prompt_id).values(**values)
        await conn.execute(query)
